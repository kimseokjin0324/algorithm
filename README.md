# algorithm
## 클래스 본체와 멤버
1. 클래스 본체에서는 다음과 같은 내용을 선언할 수 있다.
   - 멤버(필드/메서드/중첩(nested)클래스/중첩(nested)인터페이스)
   - 클래스 초기화/인스턴스 초기화
   - 생성자
2. 필드/메서드/생성자를 선언할 때 publi/protected/private을 지정할 수 있다.
3. 메서드/생성자는 다중으로 정의(오버로드)할 수 있다.
4. final로 선언한 필드는 한 번만 값을 대입할 수 있다.
5. 생성자는 새로 생성한 인스턴스의 초기화를 위해 사용
> 오버로드란 메서드나 생성자를 정의할 때 형식은 다르지만 같은 이름을 붙이는것
#### 클래스의 예
class A{

      private int f1; //비공개 필드  
      protected int f2;//한정 공개 필드
      public int f3;   // 공개 필드
      
      static final int S1=0;  //정적 상수 필드
      
      public A(){             //생성자
          f1=f2=f3=0;
     }
     public A(int f1,int f2,int f3){  //생성자
        this.f1=f1;
        this.f2=f2;
        this.f3=f3;
     }
     public void setF1(int f){      //메서드 F1의 setter
        f1=f;
     }
     
     public int getF1(){            //메서드 F1의 getter
        return f1;
     }   
}

#### 공개 클래스
클래스 접근 제한자 public을 붙여 선언한 클래스, 다른 패키지에서 사용할 수 있는 공개 클래스(public class)이다.
#### final 클래스
클래스 접근 제한자 final을 붙여 선언한 클래스로, 서브 클래스를 가질 수 없다.(새로운 클래스를 상속할 수 없다).파이널 클래스(final class)가 된다.
#### 파생 클래스 
클래스 A를 직접 상위 클래스(direct superclass)로 하려면 선언할 때 extends A를 추가해야 한다. 이때 선언한 클래스는 클래스 A의 직접 서브 클래스(direct subclass)가 된다.
클래스 선언에 extends가 없는 클래스의 상위 클래스는 Object 클래스가 된다.

#### 인터페이스 구현
인터페이스 X를 구현하려면 선언에 implements X를 추가해야한다. 
 class Y implements X{
 //...
 }
 #### 추상 클래스
 클래스 접근 제한자 abstract를 붙여 클래스를 선언하면 추상 메서드를 가질 수 있는 추상 클래스(abstract class)가 된다. 추상 클래스형은 불완전한 클래스이므로 인스턴스를 만들 수 없다.
 - 추상 메서드란 실체가 정의되지 않은 메서드이다. 실체는 서브 클래스에서 정의
 #### 중첩 클래스
 클래스 또는 인터페이스 안에 선언한 클래스는 중첩 클래스(nested class)가 된다.
   - 멤버 클래스(member class)는 그 선언이 다른 클래스 또는 인터페이스 선언에 둘러싸인 클래스이다.
   - 내부 클래스(inner class)는 명시적으로도 암묵적으로도 정적(static)으로 선언되지 않은 중첩 클래스이다. 정적 초기화나 멤버 인터페이스 선언을 할 수 없다. 그리고 컴파일을 할 때 상수 필드가 아닌 한 정적 멤버를 선언할 수 없다.
   - 지역 클래스(local class)는 이름이 주어진 중첩 클래스인 내부 클래스이다. 어떤 클래스 멤버도 될수 없다.

## 배열검색
### 알고리즘
1. 선형 검색: 무작위로 늘어놓은 데이터 모임에서 검색을 수행
2. 이진 검색: 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행
3. 해시법: 추가,삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
      - 체인법: 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
      - 오픈 주소법: 데이터를 위한 해시 값이 충동할 때 재 해시하는 방법

#### 어떤 목적을 이루기 위해 선택할 수 있는 알고리즘이 여러 가지인 경우에는 용도나 목적, 실행 속도, 자료구조 등을 고려하여 알고리즘을 선택해야한다.

## 선형 검색
배열에서 검색하는 방법 중 가장 기본적인 알고리즘
요소가 직선모양으로 늘어선 배열에서 검색은 원하는 키 값을 갖는 요소를 만날때까지 맨앞부터 순서대로 요소를 검색하는것을 선형 검색(linear search)또는 순차 검색(sequential search)라는 알고리즘이라고 한다.

> ## 무한 루프 구현
> while문은 무한루프 구조를 이루고 있다. 이 구조는 무한하게 반복하는 구조로 되어 있지만 break문이나 return 문을 사용하면 루프에서 빠져나올 수 있다.
> do문에 의한 무한 루프 구현은 권장하지 않음( 끝까지 읽지 않으면 무한 루프인지 알수 없다)


### 보초법
선형 검색은 반복할때마다 종료조건을 모두 판단한다.
> 종료조건
> 1. 검색할 값을 반견하지 못하고 배열의 끝을 지나간경우
> 2. 검색할 값과 같은 요소를 발견한 경우
이 비용을 반으로 줄이는 방법이 보초법(sentinel method)이다.
검색하기 전 검색하고 자하는 키값을 맨 끝 요소에 저장한다. 이때 저장하는 값을 보초(sentinel)이라고 한다.
이렇게 하면 원하는 키 값을 찾지 못했을 때 판단하는 종료조건이 없어도 된다.
보초는 반복문에서 종료 판단 횟수를 2회에서 1회로 줄이는 역할을 한다.

## 이진검색
이진 검색 알고리즘을 적용하는 전제 조건은 데이터가 키값으로 이미 정렬(sort)되어 있다는 것이다.
이진 검색은 선형검색보다 좀 더 빠르게 검색할 수 있다는 장점이 있다.
이진 검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘이다.

### 복잡도
프로그램의 실행 속도는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라진다.
알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도(complexity)라고 한다.
복잡도는 아래의 두가지 요소를 가지고 있다.
> 1. 시간복잡도(time complexity):실행에 필요한 시간을 평가한 것
> 2. 공간복잡도(space complexity):기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
#### 선형 검색의 시간 복잡도
    static int seqSearch(int[] a,int n,int key){
        int i=0;  //한번만 실행함 복잡도 O(1)
        while(i<n){        //복잡도 O(n)
            if(a[i]==key) //복잡도 O(n)
                return i;//검색 성공 1을 반환 한번만실행함 복잡도O(1)
            i++;        //O(n)
        }
        return -1;//검색실패 -1을 반환 한번만실행함 복잡도O(1)
    }
    
    
 > ## 컴퓨터에는 n/2나 n의 차이는 크지 않다
 > n/2번 실행했을 때 복잡도를 O(n/2)가아닌O(n)으로 표현하는 이유는 n의 값이 무한히 커진다고 가정햇을때 그 값의 차이가 무의미해 지기때문이다.
 > 마찬가지로 100번 실행하는 경우에도 O(100)이아닌 O(1)로 표현, 컴퓨터가 100번계산하닌 시간과 1번계산하는 시간의 차이는 사람이 느낄 수없을정도로 굉장히 작기때문이다.
 

그런데 n이 점점 커지면 O(n)에 필요한 계산 시간은 n에 비레하여 점점길어진다. 이와 달리 O(1)에 필요한 계산 시간은 변하지 않는다. 일반적으로 O(f(n))과 O(g(n))의 복잡도를 계산하는 방법은 아래와 같다.
O(f(n))+O(g(n))=O(max(f(n),g(n)))
2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은쪽의 복잡도를 우선시 한다. 둘이 아니라 셋 이상의 계산으로 구성된 알고리즘도 마찬가지이다. 다시 말해 전체 복잡도는 차원이 가장 높은 복잡도를 선택한다 그러므로 선형 검색 알고리즘의 복잡도를 구하면 아래처럼 O(n)이 된다.
O(1)+O(n)+O(n)+O(1)+O(n)+O(1)=O(max(1,n,n,1,n,1))=O(n)

### 이진 검색의 시간복잡도
이진검색법을 이용하면 검색할 요소의 범위를 절반씩 좁힐 수 있다.
    static int binSearch(int[] a,int n,int key){
        int pl=0;           //검색범위의 첫 인덱스  실행횟수 1/복잡도 O(1)
        int pr=n-1;         //검색범위의 끝 인덱스  실행횟수 1/복잡도 O(1)

        do{
            int pc=(pl+pr)/2;   //중앙요소의 인덱스 실행횟수 log n/복잡도 O(log n)
            if(a[pc]==key)      // 실행횟수 log n/복잡도 O(log n)
                return pc;      //검색 성공 실행횟수 1/복잡도 O(1)
            else if(a[pc]<key)  //실행 횟수 log n/복잡도 O(log n)
                pl=pc+1;        //검색 범위를 뒤쪽 절반으로 좁힘 실행 횟수 log n/복잡도 O(log n)
            else
                pr=pc-1;        //검색 범위를 앞쪽 절반으로 좁힘 실행 횟수 log n/복잡도 O(log n)
        }while(pl<=pr);         //실행 횟수 log n/복잡도 O(log n)
        return -1;              //검색 실패 실행 횟수 1 /복잡도 O(1)
    }

이진 검색 알고리즘의 복잡도를 구하면 아래처럼 O(logn)을 얻을 수 있다.
O(1)+O(1)+O(logn)+O(logn)+O(1)+O(logn)+...+O(1)=O(logn)

### 클래스 메서드와 인스턴스 메서드
Java메서드의 종류
1. 인스턴스 메서드(비정적 메서드):static을 붙이지 않고 선언한 메서드
2. 클래스 메서드(정적 메서드): static을 붙여 선언한 메서드
둘의 차이점은 메서드가 인스턴스에 포함되는지 여부이다.
클래스 메서드는 클래스 전체에 대한 처리를 담당 인스턴스 메서드와 처리 영역을 구분하기 위해 주로 사용
클래스 메서드와 마찬가지로 클래스 변수도 인스턴스에 포함되지 않는 변수이다. 또한 인스턴스의 개수와 관계없이 1개만 만들어 진다.
인스턴스 메서드와 클래스 메서드는 호출하는 방식도 다르다.
> 인스턴스 메서드 호출 시: 클래스형 변수 이름.메서드 이름
> 클래스 메서드 호출시 : 클래스 이름.메서드 이름

### 객체의 배열에서 검색하기
객체의 배열에서도 검색할 수 있다. 

> ### 자연정렬(natural ordering)
> binarySearch메서드에 배열과 키 값을 전달하는 간단한 방법으로 검색할 수 있는 이유는 String 클래스가 Comparable<T> 인터페이스와 comparetTo메서드를 구현하고 있기 때문이다.
   
   
### 제네릭
   제네릭은 처리해야 할 대상의 자료형에 의존하지 않는 클래스(인터페이스) 구현 방식이다.
   제네릭 클래스는 자료형에 의존하지 않기 때문에 범용으로 사용할 수 있다. 또한 자바에서 지원하는 기능이므로 안전한 방법으로 사용할 수 있다.
   제네릭 클래스는 클래스 이름 뒤에 <Type> 같은 형식의 파라미터를 붙여 선언
   > class 클래스 이름 <파라마터> {/*.....*/}
   > class 인터페이스 이름 <파라미터> {/*  */}
   파라미터를 쉼표로 구분하면 파라미터를 여러 개 지정할 수 있다.
   > class 클래스 이름(인터페이스 이름) <파라미터1, 파라미터2,...> {}
   이렇게 정의될 클래스나 인터페이스는 매개변수로 정의한 '자료형'을 전달받을 수 있다.
   > #### 파라미터의 이름을 작성하는 방법
   > 1. 1개의 대문자를 사용
   > 2. 컬렉션(collection)의 자료형은 element의 앞글자인 E를 사용
   > 3. 맵(Map)의 키(key),값(value)는 key와 value의 앞글자인 K와 V를 사용
   > 4. 일반적으로 T를 사용
   
   
   또한 형변수에는 와일드카드를 지정하는 것도 가능
   > * "<? extends T>" :클래스 T의 서브 클래스를 전달받는다.
   > * "<? super T>" : 클래스 T의 슈퍼 클래스를 전달받는다.
## 스택
스택은 데이터를 일시적으로 저장하기 위한 자료구조
가장 나중에 넣은 데이터를 가장 먼저 꺼낸다(LIFO)
### 스택이란?
스택(stack)은 데이터를 일시적으로 저장하기 위한 자료구조, 데이터의 입력 출력순서는 후입선출(LIFO,Last in First Out)이다.
스택에 데이터를 넣는 작업을 푸시(push), 데이터를 꺼내는 작업을 팝(Pop)이라고 한다.
푸시와 팝을 하는 위치를 꼭대기(top)이라고 하며, 스택의 가장 아랫부분을 바닥(bottom)이라고 한다.
자바 프로그램에서 메서드를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
#### 스택만들기
##### 스택 본체용 배열 :stk
푸시된 데이터를 저장하는 스택 본체의 배열이다. 인덱스 0인 요소가 스택의 바닥(bottom)이다. 가장 먼저 푸시된 데이터를 저장하는 곳은 stk[0]이다.
##### 스택 용량: max
스택 용량(스택에 쌓을 수 있는 최대 데이터 수)을 나타내는 필드이다. 이 값은 배열 stk의 요솟수와 같다.
##### 스택 포인터: ptr
스택에 쌓여있는 데이터 수를 나타내는 필드. 이 값은 스택 포인터(stack pointer)라고 한다.
## 큐
큐는 스택과 마찬가지로 데이터를 일시적으로 쌓아 놓은 자료구조이다.
큐는 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출(FIFO,First in First Out)인 점이 스택과 다르다.

### 큐란?
큐(queue)는 스택과 마찬가지로 데이터를 일시적으로 쌓아 두기 위한 자료구조이다.
가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조로 되어 있다. 
생활에서 볼 수 있는 큐의 예는 은행 창구에서 차례를 기다리는 대기열이나 마트에서 계산을 기다리는 대기열이다.
큐에 데이터를 넣는 작업을 인큐(enqueue)라 하고, 데이터를 꺼내는 작업을 디큐(dequeue)라고 한다. 또 데이터를 꺼내는 쪽을 프런트(front),데이터를 넣는 쪽을 리어(rear)라고 한다.

### 배열로 큐만들기

## 링 버퍼 활용
링 버퍼는 오래된 데이터를 버리는 용도로 사용할 수 있다.
구체적인 예로 요소의 개수가 n인 배열에 계속해서 데이터가 입력될 떄 가장 최근에 들어온 데이터 n개만 저장하고 오래된 데이터는 버리는 용도로 사용한다.
##재귀란?
어떤 사건이 자기 자신을 포함하고 다시 자기 자신을 사용하여 정의될 때 재귀적(recursive)이라고 한다.
재귀의 개념을 사용하면 1ㅜ터 시작하여 2,3,~~과 같이 무한하게 이어지는 자연수를 아래처럼 정의할 수 있다.
> 1. 1은 자연수
> 2. 자연수 n의 바로 다음 수도 자연수
재귀적 정의(recursive definition)에 의해 무한으로 존재하는 자연수를 위의 두문장으로 정의할 수 있다.
재귀를 효과적으로 사용하면 이런 정의 뿐만아니라 프로그램도 간결하게 할 수 있다. 

### 팩토리얼 구하기
재귀의 사용 예로 가장 먼저 살펴볼 문제는 음이 아닌 정수의 팩토리얼(factorial)을 구하는 프로그램이다.
음이 아닌 정수 n의 팩토리얼(n!)은 아래처럼 재귀적으로 정의할 수 있다.
1. 0!=1
2. n>0이면 n!=nx(n-1)!

### 직접 재귀와 간접 재귀
factorial 메소드는 그 내부에서 factorial 메소드를 호출합니다. 이처럼 자신과 같은 메서드를 호출하면 직접(direct) 재귀이다.
간접(indirect) 재귀는 메서드 a가 메서드b를 호출하고 다시 메서드b가 메서드 a를 호출하는 구조로 이뤄져 있다.
재귀 알고리즘에 알맞는 경우는 '풀어야할 문제','계산할 메서드','처리할 데이터 구조'가 재귀로 정의도니는 경우이다.

### 유클리드 호제법
두 정수의 최대공약수(greatest common divisor)를 재귀적으로 구하는 방법에 대해서 알아보자
두 정수를 직사각형의 두 변의 길이라고 생각하면 두 정수의 최대공약수를 구하는 문제는 다음과같다.
> 직사각형을 정사각형으로 완전히 채우고, 이렇게 만들 수 있는 정사각형의 가장 긴 변의 길이를 구한다.
이렇게 두 정수가 주어질 경우 큰값을 작은 값으로 나누었을때 나누어 떨어지는 가장 작은 값이 최대 공약수이다. 나누어지지 않으면 작은 값에 대해 나누어 떨어질때 까지 같은 과정을 재귀적으로 반복한다.
두 정수 x,y의 최대공약수를 gcd(x,y)로 표기할때 x=az,y=bz를 만족하는 정수 a,b와 최대의 정수 z가 존재할때 z를 gcd(x,y)라고 할 수 있다.
최대공약수는 y가 0이면 x이고 y가 0이 아니면 gcd(y,x%y)로 구할 수 있다. 이 알고리즘을 유클리드 호제법(Euclidean method of mutual division)이라고 한다.

## 재귀 알고리즘 분석
재귀 알고리즘을 분석하기 위한 하향식(top down) 분석과 상향식(bottom up)분석을 살펴보고 재귀 알고리즘을 비재귀적으로 구현하는 방법에 대해서 알아보자

### 재귀 알고리즘의 분석
       //재귀 함수
       static void recur(int n){
         if(n>0){
              recur(n-1);
               System.out.println(n);
               recur(n-2);
         }
       }
      public static void main(String[] args){
          Scanner stdIn=new Scanner(System.in);

           System.out.printf("정수를입력하세요:");
          int x= stdIn.nextInt();

         recur(x);
       }
recur 메서드는 메서드 안에서 재귀 호출을 2회 실행한다. 이처럼 재귀 호출식을 여러 회 실행하는 메서드를 순수하게(genuinely) 재귀적이라고 하며, 실제 동작은 매우 복잡하다.
recur 메서드를 하향식과 상향식의 두 방법으로 분석
#### 하향식 분석
매개 변수를 n으로 4를 전달하면 recur메서드는 아래의 순서대로 진행
1. recur(3)을 실행
2. 4를 출력
3. recur(2)를 실행
이렇게 하나의 작업이 완료 되어야 한 칸 위의 상자로 돌아갈수 있다.
이처럼 가장 위쪽에 위치한 상자의 메서드 호출 부터 시작해 계단식으로 자세히 조사하는 분석 기법을 하향식 분석(top-down analysis)라고 한다.

#### 상향식 분석
하향식 분석과는 대조적으로 아래쪽부터 쌓아올리면서 분석하는 방법인 상향식 분석(bottom-up analysis)이다.
recur메서는 n이 양수일때만 실행하므로 먼저 recur(1)을 생각해본다.
1. recur(0)을 실행
2. 1을 출력
3. recur(-1)을 실행
recur(2)에 대해서 생각
1. recur(1)을 실행
2. 2를 출력
3. recur(0)을 실행

### 재귀 알고리즘의 비재귀적 표현
recur메서드를 재귀 호출을 사용하지 않고 구현하는 방법에 대해서 알아보자
#### 꼬리 재귀의 제거
메서드의 꼬리에서 재귀 호출하는 메서드 recur(n-2)라는 말은 '인자로 n-2를 전달하여 recur메서드를 호출한다'는 의미이다. 따라서 아래와 같이 바꿀수 있다
> n의 값을 n-2로 업데이트하고 메서드의 시작 지점으로 돌아간다.

       static void recur(int n){
           while(n>0){
             recur(n-1);
              System.out.println(n);
              n=n-2;
         }
      }
이렇게 하면 메서드의 끝에서 실행하는 꼬리 재귀(tail recursion)는 쉽게 제거할 수 있다.

#### 재귀의 제거
꼬리 재귀와는 다르게 앞에서 호출한 재귀 메서드의 제거는 쉽지 않다.
변수 n의 값을 출력하기 전에 recur(n-1)을 먼저 수행해야 하기 때문이다.
그래서 재귀 호출 recur(n-1)을 아래처럼 바로 바꿀 수 없다.
> n의 값을 n-1으로 업데이트하고 메서드의 시작 지점으로 돌아간다.
왜냐면 다음과 같은 처리를 미리 해야 하기 때문이다.
> 현재 n의 값을 '잠시'지정한다.
또 recur(n-1)의 처리가 완료된 다음에 n의 값을 출력할 때는 다음 과정을 따르게 된다.
> 저장했던 n을 다시꺼내 그 값을 출력
이런 재귀 호출을 제거하기 위해서는 변수 n의 값을 잠시 저장해야한다는 것을 알게되었다.-> 이런 문제를 해결하기위해 스택을 이용한다.

    static void recur (int n){
        IntStack s= new IntStack;
        
        while(true){
            if(n>0){
                s.push(n);
                n=n-1;
                continue;
            }
            if(s.isEmpty(!=true)){
                n=s.pop();
                System.out.println(n);
                n=n-2;
                continue;
            }
            break;
        }
    }

recur(4)를 호출한다음 4는 0보다 크므로 맨앞의 if문에 의해 다음과 같은 과정이 진행
1. n값 4를 스택에 푸시한다.
2. n값을 하나 줄여 3으로 만든다.
3. continue문에 의해 while문의 처음으로 돌아간다.
while문에 의해 반복적으로 수행되어 스택에 4,3,2,1이 쌓이게 되고 n값이 0이 되면 첫번째 if문은 지나가고 다음의 if문에 의해 다음과 같은 과정이 진행됨
1. 스택에서 팝한 값 1을 꺼내서 n에 놓는다.
2. n 값 1을 출력
3. n값을 줄여 -1로 만든다.
4. continue문에 의해 while문의 처음으로 돌아간다.


## 하노이의 탑
쌓아 놓은 원반을 최소의 횟수로 옮기기 위한 알고리즘인 하노이의 탑에 대해 살펴보자
### 하노이의 탑
하노이의 탑은 작은 원반이 위에, 큰원반이 아래에 위치할 수 있도록 원반을 3개의 기둥 사이에서 옮기는 문제이다.문제는 원반은 크기가 다르고 처음에는 모든 원반이 이 규칙에 맞게 첫번째 기둥에 쌓여있다. 

  static void move(int no,int x,int y){
        if(no>1)
            move(no-1,x,6-x-y);
        System.out.println("원반["+no+"]을 "+x+"기둥에서"+y+"기둥으로 옮김");

        if(no>1)
            move(no-1,6-x-y,y);
    }

    public static void main(String[] args){
        Scanner stdIn=new Scanner(System.in);

        System.out.println("하노이의 탑");
        System.out.printf("원반 개수:");
        int n= stdIn.nextInt();

        move(n,1,3);
    }
1. 바닥 원반을 제외한 그룹(원반[1]~원반[no-1])을 시작 기둥에서 중간 기둥으로 옮긴다.
2. 바닥 원반 no를 시작 기둥에서 목표 기둥으로 옮겼음을 출력
3. 바닥 원반을 제외한 그룹(원반[1]~원반[no-1)을 중간 기둥에서 목표 기둥으로 옮긴다.

## 8퀸 문제
### 8퀸 문제란?
8퀸 문제(8-Queen problem)은 재귀 알고리즘에 대한 이해를 돕기 위한 예제로 자주 등장할 뿐만 아니라 19세기의 유명한 수학자 카를 프리드리히 가우스가 잘못된 해답을 낸 사실로도 잘 알려진 문제이다.
> ### 문제
> 서로 공격하여 잡을 수 없도록 8개의 퀸을 8X8체스판에 놓으시오(퀸은 서 있는 지점에서 체스판의 어떤지점으로는 여덟 방향으로 직선 이동이 가능

#### 퀸 배치하기
8개의 퀸을 배치하는 조합은 체스판 64칸에서 퀸 1개를 배치할 떄는 아무곳이나 선택가능하다. 다음 퀸을 배치할 때는 나머지 63칸에서 임의로 선택한다. 마찬가지로 8번째 까지 생각하면 다음과 같다.
> 64X63X62X61X60X59X58X57=179,462,987,637,760
가지의 조합이 만들어진다. 그런데 이 조합이 8퀸 문제의 조건을 만족하는지 조사하는 것은 현실적이지 않음. 퀸은 자신과 같은 열에 있는 다른 퀸을 공격할 수 있으므로 아래와 같은 규칙을 세운다.
> [규칙1] 각 열에 퀸 1개만 배치한다.
이렇게 하면 퀸을 배치하는 조합의 수는 많이 줄어들지만 
> 8 X 8 X 8 X 8 X 8 X 8 X 8 X 8= 16,777,216
가지로 엄청나게 많다. 하지만 이 가운에 8퀸 문제를 만족하는 풀이가 없다 왜냐하면 퀸은 자신과 같은 행에 있는 다른 퀸을 공격할 수 있기 때문이다. 
그래서 다음 규칙을 추가함
> [규칙2] 각 행에 퀸을 1개만 배치한다.

### 가지 뻗기

배열 pos는 퀸의 배치를 나타낸다. i열에 놓인 퀸의 위치가 j열이라면pos[i]의 값을 j로 한다. 예를 들어 pos[0]=0이면 0열의 퀸이 0행에 배치된 상태라고 생각하자
이때 set메서드는 pos[i]에 0부터 7까지의 값을 순서대로 만드는 재귀 메서드 이다. 매개변수 i가 이 퀸을 배치 할 열이다.
    
    // 각 열의 퀸의 위치를 출력
    static void print(){
        for(int i=0;i<8;i++)
            System.out.printf("%2d ",pos[i]);
        System.out.println();
    }
    
    // i열에 퀸을 놓는다
    static void set(int i){
        for (int j=0;j<8;j++){
            pos[i]=j;               //퀸을 j행에 배치
            if(i==7)                //모든 열에 배치함
                print();
            else
                set(i+1);           //다음 열에 퀸을 배치
            
        }
    }
    public static void main(String[] args){
        set(0);                 //0열에 퀸을 배치한다
    }

이렇게 가지를 뻗으며 퀸을 배치하는 조합을 모두 나열을 했다. 이러한 방법을 가지 뻗기(branching)라고 한다. 하노이의 탑이나 8퀸 문제처럼 문제를 세분화하고 세분된 작은 문제의 풀이를 결합해 전체 문제를 풀이하는 기법을 분할 정복법(divide and conquer)이라고 한다.
물론 문제를 세분할 때는 작은 문제의 풀이에서 원래 문제의 풀이가 쉽게 도출될 수 있게 설계해야한다.

#### 분기 한정법
가지 뻗기로 퀸을 배치하는 조합을 나열할 수는 있지만 8퀸 문제의 답을 얻을 수는 없다. 다음의 규칙을 적용해서 다시 살펴보자
> [규칙2] 각 행에 퀸을 1개만 배치한다.


public class QueenB {  
    static boolean[] flag=new boolean[8]; //각 행에 퀸을 배치했는지 체크    
    static int[] pos=new int[8];        //각 열의 퀸의 위치  

    // 각 열의 퀸의 위치를 출력
    static void print(){
        for(int i=0;i<8;i++)
            System.out.printf("%2d ",pos[i]);
        System.out.println();
    }

    // i열에 퀸을 놓는다
    static void set(int i){
        for (int j=0;j<8;j++){
            if(flag[i]==false){         // j행에는 아직 퀸을 배치하지 않았다면
                pos[i]=j;               //퀸을 j행에 배치
                if(i==7)                //모든 열에 배치함
                    print();
                else{
                    flag[i]=true;
                    set(i+1);           //다음 열에 퀸을 배치
                    flag[j]=false;
                }
            }
        }
    }
    public static void main(String[] args){
        set(0);                 //0열에 퀸을 배치한다
    }
}

flag라는 배열을 사용한다. flag는 같은 행에 중복하여 퀸이 배치되는 것을 방지하기 위한 표시(flag)이다. j행에 퀸을 배치하면 flag[j]의 값을 true로 하고,배치되지 않은 상태를 flase로 한다.
0열에 퀸을 배치하기 위해 호출한 set메서드는 먼저 0행에 퀸을 배치한다. 0해에 퀸을 배치했기 때문에 flag[0]의 값을 true로 변경. 그런 다음 set메서드를 재귀적으로 호출한다. 이렇게 호출한 set메서드는 다음 1열에 퀸을 배치한다. for문은 0행~7행까지 퀸을 배치한다. 
이처럼 필요하지 않은 분기를 없애 불필요한 조합을 줄이는 방법을 한정(bounding)조작이라고 하고, 가지 뻗기와 한정 조작을 조합하여 문제를 풀어가는 방법을 분기 한정법(branching and bounding method)라고 한다.

### 8퀸을 푸는 문제
위의 코드는 퀸이 행방향과 열방향으로 겹쳐지지 않은 조합을 나열하기만했다. => 이것은 8룩문제와 같음
퀸은 대각선으로도 이동할 수 있기때문에 어떤 대각선에서 보더라도 1개만 배치하는 한정 조작을 추가해야한다.

public class QueenB {  
    static boolean[] flag_a=new boolean[8]; //각 행에 퀸을 배치했는지 체크  
    static boolean[] flag_b=new boolean[15]; // / 대각선 방향으로 퀸을 배치했는지 체크  
    static boolean[] flag_c=new boolean[15]; // \ 대각선 방향으로 퀸을 배치했는지 체크  
    static int[] pos=new int[8];        //각 열의 퀸의 위치  

    // 각 열의 퀸의 위치를 출력
    static void print(){
        for(int i=0;i<8;i++)
            System.out.printf("%2d ",pos[i]);
        System.out.println();
    }

    // i열의 알맞은 위치에 퀸을 배치
    static void set(int i){
        for (int j=0;j<8;j++){
            if(flag_a[i]==false&& // j행에는 아직 퀸을 배치하지 않았다면
            flag_b[i+j]==false&&  // 대각선 /에 아직 배치하지 않았다면
            flag_c[i-j+7]==false) // 대각선 \에 아직 배치하지 않았다면
            {
                pos[i]=j;               //퀸을 j행에 배치
                if(i==7)                //모든 열에 배치함
                    print();
                else{
                    flag_a[j]=flag_b[i+j]=flag_c[i-j+7]=true;
                    set(i+1);
                    flag_a[j]=flag_b[i+j]=flag_c[i-j+7]=false;
                }
            }
        }
    }
    public static void main(String[] args){
        set(0);                 //0열에 퀸을 배치한다
    }
}

flag_b와 flag_c는 '/'방향과 '\'방향의 대각선 위에 퀸을 배치했는지 체크하는 배열이다.
j행i열에서 각각의 대각선 방향에 대해 퀸이 배치되었을 때 체크하는 배열의 인덱스는 flag_b[i+j], flag_c[i-j+7]이다.

## 정렬
정렬(sorting)은 이름,학번,키 등 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업을 말한다. 이 알고리즘을 이용해 데이터를 정렬하면 검색을 좀더 쉽게 할 수 있다. 
키 값이 작은 데이터를 앞쪽에 놓으면 오름차순(ascending order)정렬, 그 반대로 놓으면 내림차순(desending order)정렬이라고 부른다.
#### 정렬 알고리즘의 안정성
여러가지 정렬 알고리즘 중에서 대표적인 알고리즘 8개를 소개한다. 이때 정렬 알고리즘을 안정된(stable)알고리즘과 그렇지 않은 알고리즘으로 나눌 수 있다.
안정된 정렬이란 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것을 말한다. 안정되지 않은 알고리즘은 같은 점수인 경우 반드시 학번 순서대로 정렬하지 않는다.

#### 내부 정렬과 외부 정렬
정렬알고리즘은 하나의 배열에서 작업할 수 있는 경우에는 내부정렬(internal sorting)을 사용하고, 하나의 배열에서 작업할 수 없는 경우에는 외부 정렬(external sorting)을 사용한다.
> 1. 내부 정렬: 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘
> 2. 외부 정렬: 정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘

외부 정렬은 내부 정렬을 응용한 것으로, 외부 정렬을 구현하려면 작업을 위한 파일 등이 필요하고 알고리즘도 복잡하다. 

#### 정렬 알고리즘의 핵심 요소 
정렬 알고리즘의 핵심 요소는 `교환, 선택, 삽입` 이며 대부분의 정렬 알고리즘은 이 세 가지 요소를 응용한 것이다.

## 버블 정렬
버블 정렬은 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복한다.
n개의 요소를 가진 배열이 있으면 n-1회 비교, 교환을 하고나면 가장 작은 요소가 맨 처음으로 이동하게 된다. 그리고 이런 일련의 과정(비교,교환 작업)을 `패스(pass)`라고 한다.
> 패스의 횟수가 n-1인 이유: n-1개의 요소 정렬이 끝나면 마지막 요소는 이미 맨 끝에 놓이기 때문에 n-1회이다.

#### 버블 정렬 프로그램
변수 i의 값을 0부터 n-2까지 1씩 증가하며 n-1회의 패스(pass)를 수행하는 프로그램
>    for(int i=0;i<n-1;i++){  
>        //a[i],a[i+1],~,a[n-1]에 대해  
>        // 끝에서부터 앞쪽으로 스캔하면서 이웃하는 두 요소를 비교하고 교환한다.  
>    }


//a[idx1] a[idx2]의 값을 변경      
    static void swap(int[] a,int idx1, int idx2){
        int t=a[idx1];
        a[idx1]=a[idx2];
        a[idx2]=t;
    }

    //버블 정렬
    static void bubbleSort(int[] a,int n){
        for(int i=0;i<n-1;i++)
            for(int j=n-1;j>i;j--)
                if(a[j-1]>a[j])
                    swap(a,j-1,j);
    }

    public static void main(String[] args){
        Scanner stdIn=new Scanner(System.in);
        System.out.printf("요숫수 :");
        int nx= stdIn.nextInt();
        int[] x=new int[nx];

        for(int i=0;i<nx;i++){
            System.out.printf("x["+i+"] :");
            x[i]= stdIn.nextInt();
        }
        bubbleSort(x,nx);       //배열 x를 버블 정렬한다.
        System.out.println("오름차순으로 정렬 했습니다.");
        for(int i=0;i<nx;i++){
            System.out.println("x["+i+"] ="+x[i]);
        }
    }

#### 알고리즘 개선(1)
n번째 패스에서 정렬이 마쳐졌으면 n+1번째 패스에서 정렬을 할필요가 없다. 왜냐하면 이미 배열이 정렬을 마친 상태라면 그 이후의 패스는 요소 교환을 하지 않기 때문이다.
즉, 어떤 패스에서 요소의 교환 횟수가 0이면 더 이상 정렬할 요소가 없다는 뜻이기 때문에 정렬 작업을 멈추면 된다.

    //버블 정렬(V2)
    static void bubbleSort(int[] a,int n){
        for(int i=0;i<n-1;i++){
            int exchg=0;            // 패스의 교환 횟수를 기록한다.
            for(int j=n-1;j>i;j--)
                if(a[j-1]>a[j]){
                    swap(a,j-1,j);
                    exchg++;
                }
            if(exchg==0) break;     //교환이 이뤄지지 않으면 종료

        }

    }

변수 exchg는 패스를 시작하기 전에 0으로 초기화되고 패스에서 요소를 교환할 때마다 1씩증가한다. 따라서 패스를 마쳤을 때의 exchg 값은 한번의 패스에서 시도한 교환횟수와 같다.

#### 알고리즘 개선(2)
    //버블 정렬(V3)
    static void bubbleSort(int[] a,int n){
        int k=0;
        while(k<n-1){
            int last=n-1;
            for(int j=n-1;j>k;j--)
                if(a[j-1]>a[j]){
                    swap(a,j-1,j);
                    last=j;
                }
            k=last;
        }

    }

last는 각 패스에서 마지막으로 교환한 두 요소 가운데 오른쪽요소(a[j])의 인덱스를 저장하기 위한 변수이다. 교환을 요청할 떄마다 오른쪽 요소의 인덱스 값을 last에 저장한다. 하나의 패스를 마쳤을 때 last값을 k에 대입하여 다음에 수행할 패스의 범위를 제하한다. 그러면 다음 패스에서 마지막으로 비교할 두 요소는 a[k]와 a[k+1]이 된다.

## 단순 선택 정렬
### 단순 선택 정렬(straight selection sort)
단순 선택 정렬 알고리즘은 가장 작은 요소부터 정렬하는 알고리즘이기 때문에 가장 작은 값 요소를 선택해 정렬을 시작한다.
> ###단순 선택 정렬의 교환과정
> 1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min]을 선택한다.
> 2. a[min]과 아직 정렬하지 ㅇ낳은 부분의 첫 번째 요소를 교환한다.

이 과정을 n-1회 반복하면된다.
> for(int i=0;i<n-1;i++){  
> // min=a[i],~,a[n-1]에서 가장 작은 값을 가지는 요소의 인덱스  
> // a[i]와 a[min]의 값을 교환  
> }

    //단순 선택 정렬
    static void selectSort(int[] a, int n){
        for(int i=0, i<n-1;i++){
            int min=i;      //정렬되지 않은 부분에서 가장 작은 요소의 인덱스를 기록한다.
            for (int j=i+1;j<n;j++)
                if(a[j]<a[min])
                    min=j;
                swap(a,i,min);      //아직 정렬되지 않은 부분의 첫 요소와 가장 작은 요소를 교환한다.
        }
    }

## 단순 삽입 정렬
단순 삽입 정렬은 선택한 요소를 그보다 더 앞쪽으로 알맞은 위치에 삽입하는 작업을 반복하여 정렬하는 알고리즘이다.
단순 선택 정렬과 비슷하게 보일 수 있지만 단순 선택 정렬은 값이 가장 작은 요소를 선택해 알맞은 위치로 옮긴다는 점이 다르다
#### 단순 삽입 정렬(straight insertion sort)
정렬되지 않은 부분의 첫 번째 요소를 정렬된 열의 알맞은 위치에 삽입하는 작업을 n-1회 반복한다.
i를 1,2,~,n-1개로 1씩 증가하면서 인덱스가 i인 요소를 꺼내 알맞은 곳에 삽입한다. 알고리즘의 개요는 다음과 같다
> for(int i=1;i<n;i++){  
> //tmp <- a[i]  
> //a[0], ~~, a[i-1]의 알맞은 곳에 tmp를 삽입한다.  
> }
tmp에 a[i]를 대이하고 반복 제어용 변수 j에 i-1을 대입한 다음 아래의 두 조건 중 하나를 만족할 때까지 j를 1씩 감소하면서 대입하는 작업을 반복한다.
1. 정렬된 열의 한쪽 끝에 도달한다.
2. tmp보다 작거나 같은 key를 갖는 항목 a[j]를 발견합니다.

이때 드모르간 법칙을 적용하면 아래의 두 조건이 모두 성립할 때 까지 반복한다고 말할 수 있다.
1. j가 0보다 크다
2. a[j-1]값이 tmp보다 크다.

## 셸 정렬
셸 정렬은 단순 삽입 정렬의 장점은 살리고 단점은 보완하여 좀 더 빠르게 정렬하는 알고리즘이다.
> ### 단순삽입 정렬의 특징
> 1. 정렬을 마쳤거나 정렬을 마친 상태에서 가까우면 정렬 속도가 매우 빨라짐(장점)
> 2. 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아진다( 단점) 

셸정렬은 도널드 셸이 고안했다. 먼저 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고, 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법이다.
1. 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬한다(4-정렬), 정렬을 마친 상태에 가까워진다.
2. 4-정렬을 마친상태에서 2칸만큼떨어진 요소를 모아 그룹 2개로 나눈다. (2-정렬)
3. 1-정렬을 적용하면 정렬을 마치게된다.
셸 정렬 과정에서 수행하는 각각의 정렬을 'h-정렬'이라고 한다. 요소수가 8인 배열에서 정렬은 h값을 4,2,1로 감소하면서 7회 정렬로 정렬을 마쳤다.
정렬해야하는 횟수는 늘지만 요소 이동의 횟수가 줄어 효율적인 정렬이라고 할 수있다.

### 퀵정렬
퀵정렬은 가장 빠른 알고리즘중 하나로 널리 사용되고 있다.
#### 퀵정렬 살펴보기
퀵 정렬은 정렬속도가 매우 빠른 데서 착안해 찰스 앤터니 리처드 호어가 직접 붙인 이름이다.
그룹을 나누는 기준을 피벗(pivot)이라고 한다. 퀵 정렬은 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 모든 그룹이 1이되면 정렬을 마친다.
#### 배열을 두 그룹으로 나누기
피벗을 x, 왼쪽 끝 요소의 인덱스를 pl 오른쪽 끝 요소의 인덱스를 pr이라고 할때 그룹을 나누려면 피벗보다 작으면 배열 왼쪽으로 크면 배열오른쪽으로 옮겨야하므로 아래와 같은 작업을 수행
1. a[pl]>=x가 성립하는 요소를 찾을 때까지 pl을 오른쪽으로 스캔
2. a[pr]<=x가 성립하는 요소를 찾을 때까지 pr을 왼쪽으로 스캔
pl이 위치한 지점은 피벗값 이상의 요소가 있는 지점이고 pr이 위치한 지점은 피벗 값 이하의 요소가 있는 지점이다. 여기서 왼쪽(pl)과 오른쪽(pr)커서가 가리키는 요소 a[pl]과 a[pr]의 값을 교환한다. 그러면 피벗 이하의 값은 왼쪽으로 이동하고 피벗 이상의 값은 오른쪽으로 이동한다.
pl과 pr이 교차하면 그룹을 나누는 과정이 끝나고 배열은 아래처럼 두 그룹으로 나눠진다.
> 피벗 이하의 그룹:a[0],~,a[pl-1]
> 피벗 이상의 그룹:a[pr+1],~,a[n-1]
또 그룹을 나누는 작업이 끝난 다음 pl>pr+1인 경우에는 다음과 같은 그룹이 생길수 있다.
> 피벗이 일치하는 값을 가지는 그룹: a[pr+1],~,a[pl-1]
