# algorithm
## 클래스 본체와 멤버
1. 클래스 본체에서는 다음과 같은 내용을 선언할 수 있다.
   - 멤버(필드/메서드/중첩(nested)클래스/중첩(nested)인터페이스)
   - 클래스 초기화/인스턴스 초기화
   - 생성자
2. 필드/메서드/생성자를 선언할 때 publi/protected/private을 지정할 수 있다.
3. 메서드/생성자는 다중으로 정의(오버로드)할 수 있다.
4. final로 선언한 필드는 한 번만 값을 대입할 수 있다.
5. 생성자는 새로 생성한 인스턴스의 초기화를 위해 사용
> 오버로드란 메서드나 생성자를 정의할 때 형식은 다르지만 같은 이름을 붙이는것
#### 클래스의 예
class A{

      private int f1; //비공개 필드  
      protected int f2;//한정 공개 필드
      public int f3;   // 공개 필드
      
      static final int S1=0;  //정적 상수 필드
      
      public A(){             //생성자
          f1=f2=f3=0;
     }
     public A(int f1,int f2,int f3){  //생성자
        this.f1=f1;
        this.f2=f2;
        this.f3=f3;
     }
     public void setF1(int f){      //메서드 F1의 setter
        f1=f;
     }
     
     public int getF1(){            //메서드 F1의 getter
        return f1;
     }   
}

#### 공개 클래스
클래스 접근 제한자 public을 붙여 선언한 클래스, 다른 패키지에서 사용할 수 있는 공개 클래스(public class)이다.
#### final 클래스
클래스 접근 제한자 final을 붙여 선언한 클래스로, 서브 클래스를 가질 수 없다.(새로운 클래스를 상속할 수 없다).파이널 클래스(final class)가 된다.
#### 파생 클래스 
클래스 A를 직접 상위 클래스(direct superclass)로 하려면 선언할 때 extends A를 추가해야 한다. 이때 선언한 클래스는 클래스 A의 직접 서브 클래스(direct subclass)가 된다.
클래스 선언에 extends가 없는 클래스의 상위 클래스는 Object 클래스가 된다.

#### 인터페이스 구현
인터페이스 X를 구현하려면 선언에 implements X를 추가해야한다. 
 class Y implements X{
 //...
 }
 #### 추상 클래스
 클래스 접근 제한자 abstract를 붙여 클래스를 선언하면 추상 메서드를 가질 수 있는 추상 클래스(abstract class)가 된다. 추상 클래스형은 불완전한 클래스이므로 인스턴스를 만들 수 없다.
 - 추상 메서드란 실체가 정의되지 않은 메서드이다. 실체는 서브 클래스에서 정의
 #### 중첩 클래스
 클래스 또는 인터페이스 안에 선언한 클래스는 중첩 클래스(nested class)가 된다.
   - 멤버 클래스(member class)는 그 선언이 다른 클래스 또는 인터페이스 선언에 둘러싸인 클래스이다.
   - 내부 클래스(inner class)는 명시적으로도 암묵적으로도 정적(static)으로 선언되지 않은 중첩 클래스이다. 정적 초기화나 멤버 인터페이스 선언을 할 수 없다. 그리고 컴파일을 할 때 상수 필드가 아닌 한 정적 멤버를 선언할 수 없다.
   - 지역 클래스(local class)는 이름이 주어진 중첩 클래스인 내부 클래스이다. 어떤 클래스 멤버도 될수 없다.

## 배열검색
### 알고리즘
1. 선형 검색: 무작위로 늘어놓은 데이터 모임에서 검색을 수행
2. 이진 검색: 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행
3. 해시법: 추가,삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
      - 체인법: 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
      - 오픈 주소법: 데이터를 위한 해시 값이 충동할 때 재 해시하는 방법

#### 어떤 목적을 이루기 위해 선택할 수 있는 알고리즘이 여러 가지인 경우에는 용도나 목적, 실행 속도, 자료구조 등을 고려하여 알고리즘을 선택해야한다.

## 선형 검색
배열에서 검색하는 방법 중 가장 기본적인 알고리즘
요소가 직선모양으로 늘어선 배열에서 검색은 원하는 키 값을 갖는 요소를 만날때까지 맨앞부터 순서대로 요소를 검색하는것을 선형 검색(linear search)또는 순차 검색(sequential search)라는 알고리즘이라고 한다.

> ## 무한 루프 구현
> while문은 무한루프 구조를 이루고 있다. 이 구조는 무한하게 반복하는 구조로 되어 있지만 break문이나 return 문을 사용하면 루프에서 빠져나올 수 있다.
> do문에 의한 무한 루프 구현은 권장하지 않음( 끝까지 읽지 않으면 무한 루프인지 알수 없다)


### 보초법
선형 검색은 반복할때마다 종료조건을 모두 판단한다.
> 종료조건
> 1. 검색할 값을 반견하지 못하고 배열의 끝을 지나간경우
> 2. 검색할 값과 같은 요소를 발견한 경우
이 비용을 반으로 줄이는 방법이 보초법(sentinel method)이다.
검색하기 전 검색하고 자하는 키값을 맨 끝 요소에 저장한다. 이때 저장하는 값을 보초(sentinel)이라고 한다.
이렇게 하면 원하는 키 값을 찾지 못했을 때 판단하는 종료조건이 없어도 된다.
보초는 반복문에서 종료 판단 횟수를 2회에서 1회로 줄이는 역할을 한다.

## 이진검색
이진 검색 알고리즘을 적용하는 전제 조건은 데이터가 키값으로 이미 정렬(sort)되어 있다는 것이다.
이진 검색은 선형검색보다 좀 더 빠르게 검색할 수 있다는 장점이 있다.
이진 검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘이다.

### 복잡도
프로그램의 실행 속도는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라진다.
알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도(complexity)라고 한다.
복잡도는 아래의 두가지 요소를 가지고 있다.
> 1. 시간복잡도(time complexity):실행에 필요한 시간을 평가한 것
> 2. 공간복잡도(space complexity):기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
#### 선형 검색의 시간 복잡도
    static int seqSearch(int[] a,int n,int key){
        int i=0;  //한번만 실행함 복잡도 O(1)
        while(i<n){        //복잡도 O(n)
            if(a[i]==key) //복잡도 O(n)
                return i;//검색 성공 1을 반환 한번만실행함 복잡도O(1)
            i++;        //O(n)
        }
        return -1;//검색실패 -1을 반환 한번만실행함 복잡도O(1)
    }
    
    
 > ## 컴퓨터에는 n/2나 n의 차이는 크지 않다
 > n/2번 실행했을 때 복잡도를 O(n/2)가아닌O(n)으로 표현하는 이유는 n의 값이 무한히 커진다고 가정햇을때 그 값의 차이가 무의미해 지기때문이다.
 > 마찬가지로 100번 실행하는 경우에도 O(100)이아닌 O(1)로 표현, 컴퓨터가 100번계산하닌 시간과 1번계산하는 시간의 차이는 사람이 느낄 수없을정도로 굉장히 작기때문이다.
 

그런데 n이 점점 커지면 O(n)에 필요한 계산 시간은 n에 비레하여 점점길어진다. 이와 달리 O(1)에 필요한 계산 시간은 변하지 않는다. 일반적으로 O(f(n))과 O(g(n))의 복잡도를 계산하는 방법은 아래와 같다.
O(f(n))+O(g(n))=O(max(f(n),g(n)))
2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은쪽의 복잡도를 우선시 한다. 둘이 아니라 셋 이상의 계산으로 구성된 알고리즘도 마찬가지이다. 다시 말해 전체 복잡도는 차원이 가장 높은 복잡도를 선택한다 그러므로 선형 검색 알고리즘의 복잡도를 구하면 아래처럼 O(n)이 된다.
O(1)+O(n)+O(n)+O(1)+O(n)+O(1)=O(max(1,n,n,1,n,1))=O(n)

### 이진 검색의 시간복잡도
이진검색법을 이용하면 검색할 요소의 범위를 절반씩 좁힐 수 있다.
    static int binSearch(int[] a,int n,int key){
        int pl=0;           //검색범위의 첫 인덱스  실행횟수 1/복잡도 O(1)
        int pr=n-1;         //검색범위의 끝 인덱스  실행횟수 1/복잡도 O(1)

        do{
            int pc=(pl+pr)/2;   //중앙요소의 인덱스 실행횟수 log n/복잡도 O(log n)
            if(a[pc]==key)      // 실행횟수 log n/복잡도 O(log n)
                return pc;      //검색 성공 실행횟수 1/복잡도 O(1)
            else if(a[pc]<key)  //실행 횟수 log n/복잡도 O(log n)
                pl=pc+1;        //검색 범위를 뒤쪽 절반으로 좁힘 실행 횟수 log n/복잡도 O(log n)
            else
                pr=pc-1;        //검색 범위를 앞쪽 절반으로 좁힘 실행 횟수 log n/복잡도 O(log n)
        }while(pl<=pr);         //실행 횟수 log n/복잡도 O(log n)
        return -1;              //검색 실패 실행 횟수 1 /복잡도 O(1)
    }

이진 검색 알고리즘의 복잡도를 구하면 아래처럼 O(logn)을 얻을 수 있다.
O(1)+O(1)+O(logn)+O(logn)+O(1)+O(logn)+...+O(1)=O(logn)

### 클래스 메서드와 인스턴스 메서드
Java메서드의 종류
1. 인스턴스 메서드(비정적 메서드):static을 붙이지 않고 선언한 메서드
2. 클래스 메서드(정적 메서드): static을 붙여 선언한 메서드
둘의 차이점은 메서드가 인스턴스에 포함되는지 여부이다.
클래스 메서드는 클래스 전체에 대한 처리를 담당 인스턴스 메서드와 처리 영역을 구분하기 위해 주로 사용
클래스 메서드와 마찬가지로 클래스 변수도 인스턴스에 포함되지 않는 변수이다. 또한 인스턴스의 개수와 관계없이 1개만 만들어 진다.
인스턴스 메서드와 클래스 메서드는 호출하는 방식도 다르다.
> 인스턴스 메서드 호출 시: 클래스형 변수 이름.메서드 이름
> 클래스 메서드 호출시 : 클래스 이름.메서드 이름

### 객체의 배열에서 검색하기
객체의 배열에서도 검색할 수 있다. 

> ### 자연정렬(natural ordering)
> binarySearch메서드에 배열과 키 값을 전달하는 간단한 방법으로 검색할 수 있는 이유는 String 클래스가 Comparable<T> 인터페이스와 comparetTo메서드를 구현하고 있기 때문이다.
   
   
### 제네릭
   제네릭은 처리해야 할 대상의 자료형에 의존하지 않는 클래스(인터페이스) 구현 방식이다.
   제네릭 클래스는 자료형에 의존하지 않기 때문에 범용으로 사용할 수 있다. 또한 자바에서 지원하는 기능이므로 안전한 방법으로 사용할 수 있다.
   제네릭 클래스는 클래스 이름 뒤에 <Type> 같은 형식의 파라미터를 붙여 선언
   > class 클래스 이름 <파라마터> {/*.....*/}
   > class 인터페이스 이름 <파라미터> {/*  */}
   파라미터를 쉼표로 구분하면 파라미터를 여러 개 지정할 수 있다.
   > class 클래스 이름(인터페이스 이름) <파라미터1, 파라미터2,...> {}
   이렇게 정의될 클래스나 인터페이스는 매개변수로 정의한 '자료형'을 전달받을 수 있다.
   > #### 파라미터의 이름을 작성하는 방법
   > 1. 1개의 대문자를 사용
   > 2. 컬렉션(collection)의 자료형은 element의 앞글자인 E를 사용
   > 3. 맵(Map)의 키(key),값(value)는 key와 value의 앞글자인 K와 V를 사용
   > 4. 일반적으로 T를 사용
   
   
   또한 형변수에는 와일드카드를 지정하는 것도 가능
   > * "<? extends T>" :클래스 T의 서브 클래스를 전달받는다.
   > * "<? super T>" : 클래스 T의 슈퍼 클래스를 전달받는다.
## 스택
스택은 데이터를 일시적으로 저장하기 위한 자료구조
가장 나중에 넣은 데이터를 가장 먼저 꺼낸다(LIFO)
### 스택이란?
스택(stack)은 데이터를 일시적으로 저장하기 위한 자료구조, 데이터의 입력 출력순서는 후입선출(LIFO,Last in First Out)이다.
스택에 데이터를 넣는 작업을 푸시(push), 데이터를 꺼내는 작업을 팝(Pop)이라고 한다.
푸시와 팝을 하는 위치를 꼭대기(top)이라고 하며, 스택의 가장 아랫부분을 바닥(bottom)이라고 한다.
자바 프로그램에서 메서드를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
#### 스택만들기
##### 스택 본체용 배열 :stk
푸시된 데이터를 저장하는 스택 본체의 배열이다. 인덱스 0인 요소가 스택의 바닥(bottom)이다. 가장 먼저 푸시된 데이터를 저장하는 곳은 stk[0]이다.
##### 스택 용량: max
스택 용량(스택에 쌓을 수 있는 최대 데이터 수)을 나타내는 필드이다. 이 값은 배열 stk의 요솟수와 같다.
##### 스택 포인터: ptr
스택에 쌓여있는 데이터 수를 나타내는 필드. 이 값은 스택 포인터(stack pointer)라고 한다.
## 큐
큐는 스택과 마찬가지로 데이터를 일시적으로 쌓아 놓은 자료구조이다.
큐는 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출(FIFO,First in First Out)인 점이 스택과 다르다.

### 큐란?
큐(queue)는 스택과 마찬가지로 데이터를 일시적으로 쌓아 두기 위한 자료구조이다.
가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조로 되어 있다. 
생활에서 볼 수 있는 큐의 예는 은행 창구에서 차례를 기다리는 대기열이나 마트에서 계산을 기다리는 대기열이다.
큐에 데이터를 넣는 작업을 인큐(enqueue)라 하고, 데이터를 꺼내는 작업을 디큐(dequeue)라고 한다. 또 데이터를 꺼내는 쪽을 프런트(front),데이터를 넣는 쪽을 리어(rear)라고 한다.

### 배열로 큐만들기

## 링 버퍼 활용
링 버퍼는 오래된 데이터를 버리는 용도로 사용할 수 있다.
구체적인 예로 요소의 개수가 n인 배열에 계속해서 데이터가 입력될 떄 가장 최근에 들어온 데이터 n개만 저장하고 오래된 데이터는 버리는 용도로 사용한다.
##재귀란?
어떤 사건이 자기 자신을 포함하고 다시 자기 자신을 사용하여 정의될 때 재귀적(recursive)이라고 한다.
재귀의 개념을 사용하면 1ㅜ터 시작하여 2,3,~~과 같이 무한하게 이어지는 자연수를 아래처럼 정의할 수 있다.
> 1. 1은 자연수
> 2. 자연수 n의 바로 다음 수도 자연수
재귀적 정의(recursive definition)에 의해 무한으로 존재하는 자연수를 위의 두문장으로 정의할 수 있다.
재귀를 효과적으로 사용하면 이런 정의 뿐만아니라 프로그램도 간결하게 할 수 있다. 

### 팩토리얼 구하기
재귀의 사용 예로 가장 먼저 살펴볼 문제는 음이 아닌 정수의 팩토리얼(factorial)을 구하는 프로그램이다.
음이 아닌 정수 n의 팩토리얼(n!)은 아래처럼 재귀적으로 정의할 수 있다.
1. 0!=1
2. n>0이면 n!=nx(n-1)!

### 직접 재귀와 간접 재귀
factorial 메소드는 그 내부에서 factorial 메소드를 호출합니다. 이처럼 자신과 같은 메서드를 호출하면 직접(direct) 재귀이다.
간접(indirect) 재귀는 메서드 a가 메서드b를 호출하고 다시 메서드b가 메서드 a를 호출하는 구조로 이뤄져 있다.
재귀 알고리즘에 알맞는 경우는 '풀어야할 문제','계산할 메서드','처리할 데이터 구조'가 재귀로 정의도니는 경우이다.

### 유클리드 호제법
두 정수의 최대공약수(greatest common divisor)를 재귀적으로 구하는 방법에 대해서 알아보자
두 정수를 직사각형의 두 변의 길이라고 생각하면 두 정수의 최대공약수를 구하는 문제는 다음과같다.
> 직사각형을 정사각형으로 완전히 채우고, 이렇게 만들 수 있는 정사각형의 가장 긴 변의 길이를 구한다.
이렇게 두 정수가 주어질 경우 큰값을 작은 값으로 나누었을때 나누어 떨어지는 가장 작은 값이 최대 공약수이다. 나누어지지 않으면 작은 값에 대해 나누어 떨어질때 까지 같은 과정을 재귀적으로 반복한다.
두 정수 x,y의 최대공약수를 gcd(x,y)로 표기할때 x=az,y=bz를 만족하는 정수 a,b와 최대의 정수 z가 존재할때 z를 gcd(x,y)라고 할 수 있다.
최대공약수는 y가 0이면 x이고 y가 0이 아니면 gcd(y,x%y)로 구할 수 있다. 이 알고리즘을 유클리드 호제법(Euclidean method of mutual division)이라고 한다.

## 재귀 알고리즘 분석
재귀 알고리즘을 분석하기 위한 하향식(top down) 분석과 상향식(bottom up)분석을 살펴보고 재귀 알고리즘을 비재귀적으로 구현하는 방법에 대해서 알아보자
