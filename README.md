# algorithm
## 클래스 본체와 멤버
1. 클래스 본체에서는 다음과 같은 내용을 선언할 수 있다.
   - 멤버(필드/메서드/중첩(nested)클래스/중첩(nested)인터페이스)
   - 클래스 초기화/인스턴스 초기화
   - 생성자
2. 필드/메서드/생성자를 선언할 때 publi/protected/private을 지정할 수 있다.
3. 메서드/생성자는 다중으로 정의(오버로드)할 수 있다.
4. final로 선언한 필드는 한 번만 값을 대입할 수 있다.
5. 생성자는 새로 생성한 인스턴스의 초기화를 위해 사용
> 오버로드란 메서드나 생성자를 정의할 때 형식은 다르지만 같은 이름을 붙이는것
#### 클래스의 예
class A{

      private int f1; //비공개 필드  
      protected int f2;//한정 공개 필드
      public int f3;   // 공개 필드
      
      static final int S1=0;  //정적 상수 필드
      
      public A(){             //생성자
          f1=f2=f3=0;
     }
     public A(int f1,int f2,int f3){  //생성자
        this.f1=f1;
        this.f2=f2;
        this.f3=f3;
     }
     public void setF1(int f){      //메서드 F1의 setter
        f1=f;
     }
     
     public int getF1(){            //메서드 F1의 getter
        return f1;
     }   
}

#### 공개 클래스
클래스 접근 제한자 public을 붙여 선언한 클래스, 다른 패키지에서 사용할 수 있는 공개 클래스(public class)이다.
#### final 클래스
클래스 접근 제한자 final을 붙여 선언한 클래스로, 서브 클래스를 가질 수 없다.(새로운 클래스를 상속할 수 없다).파이널 클래스(final class)가 된다.
#### 파생 클래스 
클래스 A를 직접 상위 클래스(direct superclass)로 하려면 선언할 때 extends A를 추가해야 한다. 이때 선언한 클래스는 클래스 A의 직접 서브 클래스(direct subclass)가 된다.
클래스 선언에 extends가 없는 클래스의 상위 클래스는 Object 클래스가 된다.

#### 인터페이스 구현
인터페이스 X를 구현하려면 선언에 implements X를 추가해야한다. 
 class Y implements X{
 //...
 }
 #### 추상 클래스
 클래스 접근 제한자 abstract를 붙여 클래스를 선언하면 추상 메서드를 가질 수 있는 추상 클래스(abstract class)가 된다. 추상 클래스형은 불완전한 클래스이므로 인스턴스를 만들 수 없다.
 - 추상 메서드란 실체가 정의되지 않은 메서드이다. 실체는 서브 클래스에서 정의
 #### 중첩 클래스
 클래스 또는 인터페이스 안에 선언한 클래스는 중첩 클래스(nested class)가 된다.
   - 멤버 클래스(member class)는 그 선언이 다른 클래스 또는 인터페이스 선언에 둘러싸인 클래스이다.
   - 내부 클래스(inner class)는 명시적으로도 암묵적으로도 정적(static)으로 선언되지 않은 중첩 클래스이다. 정적 초기화나 멤버 인터페이스 선언을 할 수 없다. 그리고 컴파일을 할 때 상수 필드가 아닌 한 정적 멤버를 선언할 수 없다.
   - 지역 클래스(local class)는 이름이 주어진 중첩 클래스인 내부 클래스이다. 어떤 클래스 멤버도 될수 없다.

## 배열검색
### 알고리즘
1. 선형 검색: 무작위로 늘어놓은 데이터 모임에서 검색을 수행
2. 이진 검색: 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행
3. 해시법: 추가,삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
      - 체인법: 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
      - 오픈 주소법: 데이터를 위한 해시 값이 충동할 때 재 해시하는 방법

#### 어떤 목적을 이루기 위해 선택할 수 있는 알고리즘이 여러 가지인 경우에는 용도나 목적, 실행 속도, 자료구조 등을 고려하여 알고리즘을 선택해야한다.

## 선형 검색
배열에서 검색하는 방법 중 가장 기본적인 알고리즘
요소가 직선모양으로 늘어선 배열에서 검색은 원하는 키 값을 갖는 요소를 만날때까지 맨앞부터 순서대로 요소를 검색하는것을 선형 검색(linear search)또는 순차 검색(sequential search)라는 알고리즘이라고 한다.

> ## 무한 루프 구현
> while문은 무한루프 구조를 이루고 있다. 이 구조는 무한하게 반복하는 구조로 되어 있지만 break문이나 return 문을 사용하면 루프에서 빠져나올 수 있다.
> do문에 의한 무한 루프 구현은 권장하지 않음( 끝까지 읽지 않으면 무한 루프인지 알수 없다)


### 보초법
선형 검색은 반복할때마다 종료조건을 모두 판단한다.
> 종료조건
> 1. 검색할 값을 반견하지 못하고 배열의 끝을 지나간경우
> 2. 검색할 값과 같은 요소를 발견한 경우
이 비용을 반으로 줄이는 방법이 보초법(sentinel method)이다.
검색하기 전 검색하고 자하는 키값을 맨 끝 요소에 저장한다. 이때 저장하는 값을 보초(sentinel)이라고 한다.
이렇게 하면 원하는 키 값을 찾지 못했을 때 판단하는 종료조건이 없어도 된다.
보초는 반복문에서 종료 판단 횟수를 2회에서 1회로 줄이는 역할을 한다.

## 이진검색
이진 검색 알고리즘을 적용하는 전제 조건은 데이터가 키값으로 이미 정렬(sort)되어 있다는 것이다.
이진 검색은 선형검색보다 좀 더 빠르게 검색할 수 있다는 장점이 있다.
이진 검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘이다.

### 복잡도
프로그램의 실행 속도는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라진다.
알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도(complexity)라고 한다.
복잡도는 아래의 두가지 요소를 가지고 있다.
> 1. 시간복잡도(time complexity):실행에 필요한 시간을 평가한 것
> 2. 공간복잡도(space complexity):기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
#### 선형 검색의 시간 복잡도
    static int seqSearch(int[] a,int n,int key){
        int i=0;  //한번만 실행함 복잡도 O(1)
        while(i<n){        //복잡도 O(n)
            if(a[i]==key) //복잡도 O(n)
                return i;//검색 성공 1을 반환 한번만실행함 복잡도O(1)
            i++;        //O(n)
        }
        return -1;//검색실패 -1을 반환 한번만실행함 복잡도O(1)
    }
    
    
 > ## 컴퓨터에는 n/2나 n의 차이는 크지 않다
 > n/2번 실행했을 때 복잡도를 O(n/2)가아닌O(n)으로 표현하는 이유는 n의 값이 무한히 커진다고 가정햇을때 그 값의 차이가 무의미해 지기때문이다.
 > 마찬가지로 100번 실행하는 경우에도 O(100)이아닌 O(1)로 표현, 컴퓨터가 100번계산하닌 시간과 1번계산하는 시간의 차이는 사람이 느낄 수없을정도로 굉장히 작기때문이다.
 

그런데 n이 점점 커지면 O(n)에 필요한 계산 시간은 n에 비레하여 점점길어진다. 이와 달리 O(1)에 필요한 계산 시간은 변하지 않는다. 일반적으로 O(f(n))과 O(g(n))의 복잡도를 계산하는 방법은 아래와 같다.
O(f(n))+O(g(n))=O(max(f(n),g(n)))
2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은쪽의 복잡도를 우선시 한다. 둘이 아니라 셋 이상의 계산으로 구성된 알고리즘도 마찬가지이다. 다시 말해 전체 복잡도는 차원이 가장 높은 복잡도를 선택한다 그러므로 선형 검색 알고리즘의 복잡도를 구하면 아래처럼 O(n)이 된다.
O(1)+O(n)+O(n)+O(1)+O(n)+O(1)=O(max(1,n,n,1,n,1))=O(n)

### 이진 검색의 시간복잡도
이진검색법을 이용하면 검색할 요소의 범위를 절반씩 좁힐 수 있다.
    static int binSearch(int[] a,int n,int key){
        int pl=0;           //검색범위의 첫 인덱스  실행횟수 1/복잡도 O(1)
        int pr=n-1;         //검색범위의 끝 인덱스  실행횟수 1/복잡도 O(1)

        do{
            int pc=(pl+pr)/2;   //중앙요소의 인덱스 실행횟수 log n/복잡도 O(log n)
            if(a[pc]==key)      // 실행횟수 log n/복잡도 O(log n)
                return pc;      //검색 성공 실행횟수 1/복잡도 O(1)
            else if(a[pc]<key)  //실행 횟수 log n/복잡도 O(log n)
                pl=pc+1;        //검색 범위를 뒤쪽 절반으로 좁힘 실행 횟수 log n/복잡도 O(log n)
            else
                pr=pc-1;        //검색 범위를 앞쪽 절반으로 좁힘 실행 횟수 log n/복잡도 O(log n)
        }while(pl<=pr);         //실행 횟수 log n/복잡도 O(log n)
        return -1;              //검색 실패 실행 횟수 1 /복잡도 O(1)
    }

이진 검색 알고리즘의 복잡도를 구하면 아래처럼 O(logn)을 얻을 수 있다.
O(1)+O(1)+O(logn)+O(logn)+O(1)+O(logn)+...+O(1)=O(logn)

### 클래스 메서드와 인스턴스 메서드
Java메서드의 종류
1. 인스턴스 메서드(비정적 메서드):static을 붙이지 않고 선언한 메서드
2. 클래스 메서드(정적 메서드): static을 붙여 선언한 메서드
둘의 차이점은 메서드가 인스턴스에 포함되는지 여부이다.
클래스 메서드는 클래스 전체에 대한 처리를 담당 인스턴스 메서드와 처리 영역을 구분하기 위해 주로 사용
클래스 메서드와 마찬가지로 클래스 변수도 인스턴스에 포함되지 않는 변수이다. 또한 인스턴스의 개수와 관계없이 1개만 만들어 진다.
인스턴스 메서드와 클래스 메서드는 호출하는 방식도 다르다.
> 인스턴스 메서드 호출 시: 클래스형 변수 이름.메서드 이름
> 클래스 메서드 호출시 : 클래스 이름.메서드 이름

### 객체의 배열에서 검색하기
객체의 배열에서도 검색할 수 있다. 

> ### 자연정렬(natural ordering)
> binarySearch메서드에 배열과 키 값을 전달하는 간단한 방법으로 검색할 수 있는 이유는 String 클래스가 Comparable<T> 인터페이스와 comparetTo메서드를 구현하고 있기 때문이다.
   
   
### 제네릭
   제네릭은 처리해야 할 대상의 자료형에 의존하지 않는 클래스(인터페이스) 구현 방식이다.
   제네릭 클래스는 자료형에 의존하지 않기 때문에 범용으로 사용할 수 있다. 또한 자바에서 지원하는 기능이므로 안전한 방법으로 사용할 수 있다.
   제네릭 클래스는 클래스 이름 뒤에 <Type> 같은 형식의 파라미터를 붙여 선언
   > class 클래스 이름 <파라마터> {/*.....*/}
   > class 인터페이스 이름 <파라미터> {/*  */}
   파라미터를 쉼표로 구분하면 파라미터를 여러 개 지정할 수 있다.
   > class 클래스 이름(인터페이스 이름) <파라미터1, 파라미터2,...> {}
   이렇게 정의될 클래스나 인터페이스는 매개변수로 정의한 '자료형'을 전달받을 수 있다.
   > #### 파라미터의 이름을 작성하는 방법
   > 1. 1개의 대문자를 사용
   > 2. 컬렉션(collection)의 자료형은 element의 앞글자인 E를 사용
   > 3. 맵(Map)의 키(key),값(value)는 key와 value의 앞글자인 K와 V를 사용
   > 4. 일반적으로 T를 사용
   
   
   또한 형변수에는 와일드카드를 지정하는 것도 가능
   > * "<? extends T>" :클래스 T의 서브 클래스를 전달받는다.
   > * "<? super T>" : 클래스 T의 슈퍼 클래스를 전달받는다.
## 스택
스택은 데이터를 일시적으로 저장하기 위한 자료구조
가장 나중에 넣은 데이터를 가장 먼저 꺼낸다(LIFO)
### 스택이란?
스택(stack)은 데이터를 일시적으로 저장하기 위한 자료구조, 데이터의 입력 출력순서는 후입선출(LIFO,Last in First Out)이다.
스택에 데이터를 넣는 작업을 푸시(push), 데이터를 꺼내는 작업을 팝(Pop)이라고 한다.
푸시와 팝을 하는 위치를 꼭대기(top)이라고 하며, 스택의 가장 아랫부분을 바닥(bottom)이라고 한다.
자바 프로그램에서 메서드를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
#### 스택만들기
##### 스택 본체용 배열 :stk
푸시된 데이터를 저장하는 스택 본체의 배열이다. 인덱스 0인 요소가 스택의 바닥(bottom)이다. 가장 먼저 푸시된 데이터를 저장하는 곳은 stk[0]이다.
##### 스택 용량: max
스택 용량(스택에 쌓을 수 있는 최대 데이터 수)을 나타내는 필드이다. 이 값은 배열 stk의 요솟수와 같다.
##### 스택 포인터: ptr
스택에 쌓여있는 데이터 수를 나타내는 필드. 이 값은 스택 포인터(stack pointer)라고 한다.
## 큐
큐는 스택과 마찬가지로 데이터를 일시적으로 쌓아 놓은 자료구조이다.
큐는 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출(FIFO,First in First Out)인 점이 스택과 다르다.

### 큐란?
큐(queue)는 스택과 마찬가지로 데이터를 일시적으로 쌓아 두기 위한 자료구조이다.
가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조로 되어 있다. 
생활에서 볼 수 있는 큐의 예는 은행 창구에서 차례를 기다리는 대기열이나 마트에서 계산을 기다리는 대기열이다.
큐에 데이터를 넣는 작업을 인큐(enqueue)라 하고, 데이터를 꺼내는 작업을 디큐(dequeue)라고 한다. 또 데이터를 꺼내는 쪽을 프런트(front),데이터를 넣는 쪽을 리어(rear)라고 한다.

### 배열로 큐만들기

## 링 버퍼 활용
링 버퍼는 오래된 데이터를 버리는 용도로 사용할 수 있다.
구체적인 예로 요소의 개수가 n인 배열에 계속해서 데이터가 입력될 떄 가장 최근에 들어온 데이터 n개만 저장하고 오래된 데이터는 버리는 용도로 사용한다.
##재귀란?
어떤 사건이 자기 자신을 포함하고 다시 자기 자신을 사용하여 정의될 때 재귀적(recursive)이라고 한다.
재귀의 개념을 사용하면 1ㅜ터 시작하여 2,3,~~과 같이 무한하게 이어지는 자연수를 아래처럼 정의할 수 있다.
> 1. 1은 자연수
> 2. 자연수 n의 바로 다음 수도 자연수
재귀적 정의(recursive definition)에 의해 무한으로 존재하는 자연수를 위의 두문장으로 정의할 수 있다.
재귀를 효과적으로 사용하면 이런 정의 뿐만아니라 프로그램도 간결하게 할 수 있다. 

### 팩토리얼 구하기
재귀의 사용 예로 가장 먼저 살펴볼 문제는 음이 아닌 정수의 팩토리얼(factorial)을 구하는 프로그램이다.
음이 아닌 정수 n의 팩토리얼(n!)은 아래처럼 재귀적으로 정의할 수 있다.
1. 0!=1
2. n>0이면 n!=nx(n-1)!

### 직접 재귀와 간접 재귀
factorial 메소드는 그 내부에서 factorial 메소드를 호출합니다. 이처럼 자신과 같은 메서드를 호출하면 직접(direct) 재귀이다.
간접(indirect) 재귀는 메서드 a가 메서드b를 호출하고 다시 메서드b가 메서드 a를 호출하는 구조로 이뤄져 있다.
재귀 알고리즘에 알맞는 경우는 '풀어야할 문제','계산할 메서드','처리할 데이터 구조'가 재귀로 정의도니는 경우이다.

### 유클리드 호제법
두 정수의 최대공약수(greatest common divisor)를 재귀적으로 구하는 방법에 대해서 알아보자
두 정수를 직사각형의 두 변의 길이라고 생각하면 두 정수의 최대공약수를 구하는 문제는 다음과같다.
> 직사각형을 정사각형으로 완전히 채우고, 이렇게 만들 수 있는 정사각형의 가장 긴 변의 길이를 구한다.
이렇게 두 정수가 주어질 경우 큰값을 작은 값으로 나누었을때 나누어 떨어지는 가장 작은 값이 최대 공약수이다. 나누어지지 않으면 작은 값에 대해 나누어 떨어질때 까지 같은 과정을 재귀적으로 반복한다.
두 정수 x,y의 최대공약수를 gcd(x,y)로 표기할때 x=az,y=bz를 만족하는 정수 a,b와 최대의 정수 z가 존재할때 z를 gcd(x,y)라고 할 수 있다.
최대공약수는 y가 0이면 x이고 y가 0이 아니면 gcd(y,x%y)로 구할 수 있다. 이 알고리즘을 유클리드 호제법(Euclidean method of mutual division)이라고 한다.

## 재귀 알고리즘 분석
재귀 알고리즘을 분석하기 위한 하향식(top down) 분석과 상향식(bottom up)분석을 살펴보고 재귀 알고리즘을 비재귀적으로 구현하는 방법에 대해서 알아보자

### 재귀 알고리즘의 분석
       //재귀 함수
       static void recur(int n){
         if(n>0){
              recur(n-1);
               System.out.println(n);
               recur(n-2);
         }
       }
      public static void main(String[] args){
          Scanner stdIn=new Scanner(System.in);

           System.out.printf("정수를입력하세요:");
          int x= stdIn.nextInt();

         recur(x);
       }
recur 메서드는 메서드 안에서 재귀 호출을 2회 실행한다. 이처럼 재귀 호출식을 여러 회 실행하는 메서드를 순수하게(genuinely) 재귀적이라고 하며, 실제 동작은 매우 복잡하다.
recur 메서드를 하향식과 상향식의 두 방법으로 분석
#### 하향식 분석
매개 변수를 n으로 4를 전달하면 recur메서드는 아래의 순서대로 진행
1. recur(3)을 실행
2. 4를 출력
3. recur(2)를 실행
이렇게 하나의 작업이 완료 되어야 한 칸 위의 상자로 돌아갈수 있다.
이처럼 가장 위쪽에 위치한 상자의 메서드 호출 부터 시작해 계단식으로 자세히 조사하는 분석 기법을 하향식 분석(top-down analysis)라고 한다.

#### 상향식 분석
하향식 분석과는 대조적으로 아래쪽부터 쌓아올리면서 분석하는 방법인 상향식 분석(bottom-up analysis)이다.
recur메서는 n이 양수일때만 실행하므로 먼저 recur(1)을 생각해본다.
1. recur(0)을 실행
2. 1을 출력
3. recur(-1)을 실행
recur(2)에 대해서 생각
1. recur(1)을 실행
2. 2를 출력
3. recur(0)을 실행

### 재귀 알고리즘의 비재귀적 표현
recur메서드를 재귀 호출을 사용하지 않고 구현하는 방법에 대해서 알아보자
#### 꼬리 재귀의 제거
메서드의 꼬리에서 재귀 호출하는 메서드 recur(n-2)라는 말은 '인자로 n-2를 전달하여 recur메서드를 호출한다'는 의미이다. 따라서 아래와 같이 바꿀수 있다
> n의 값을 n-2로 업데이트하고 메서드의 시작 지점으로 돌아간다.

       static void recur(int n){
           while(n>0){
             recur(n-1);
              System.out.println(n);
              n=n-2;
         }
      }
이렇게 하면 메서드의 끝에서 실행하는 꼬리 재귀(tail recursion)는 쉽게 제거할 수 있다.

#### 재귀의 제거
꼬리 재귀와는 다르게 앞에서 호출한 재귀 메서드의 제거는 쉽지 않다.
변수 n의 값을 출력하기 전에 recur(n-1)을 먼저 수행해야 하기 때문이다.
그래서 재귀 호출 recur(n-1)을 아래처럼 바로 바꿀 수 없다.
> n의 값을 n-1으로 업데이트하고 메서드의 시작 지점으로 돌아간다.
왜냐면 다음과 같은 처리를 미리 해야 하기 때문이다.
> 현재 n의 값을 '잠시'지정한다.
또 recur(n-1)의 처리가 완료된 다음에 n의 값을 출력할 때는 다음 과정을 따르게 된다.
> 저장했던 n을 다시꺼내 그 값을 출력
이런 재귀 호출을 제거하기 위해서는 변수 n의 값을 잠시 저장해야한다는 것을 알게되었다.-> 이런 문제를 해결하기위해 스택을 이용한다.

    static void recur (int n){
        IntStack s= new IntStack;
        
        while(true){
            if(n>0){
                s.push(n);
                n=n-1;
                continue;
            }
            if(s.isEmpty(!=true)){
                n=s.pop();
                System.out.println(n);
                n=n-2;
                continue;
            }
            break;
        }
    }

recur(4)를 호출한다음 4는 0보다 크므로 맨앞의 if문에 의해 다음과 같은 과정이 진행
1. n값 4를 스택에 푸시한다.
2. n값을 하나 줄여 3으로 만든다.
3. continue문에 의해 while문의 처음으로 돌아간다.
while문에 의해 반복적으로 수행되어 스택에 4,3,2,1이 쌓이게 되고 n값이 0이 되면 첫번째 if문은 지나가고 다음의 if문에 의해 다음과 같은 과정이 진행됨
1. 스택에서 팝한 값 1을 꺼내서 n에 놓는다.
2. n 값 1을 출력
3. n값을 줄여 -1로 만든다.
4. continue문에 의해 while문의 처음으로 돌아간다.


## 하노이의 탑
쌓아 놓은 원반을 최소의 횟수로 옮기기 위한 알고리즘인 하노이의 탑에 대해 살펴보자
### 하노이의 탑
하노이의 탑은 작은 원반이 위에, 큰원반이 아래에 위치할 수 있도록 원반을 3개의 기둥 사이에서 옮기는 문제이다.문제는 원반은 크기가 다르고 처음에는 모든 원반이 이 규칙에 맞게 첫번째 기둥에 쌓여있다. 

  static void move(int no,int x,int y){
        if(no>1)
            move(no-1,x,6-x-y);
        System.out.println("원반["+no+"]을 "+x+"기둥에서"+y+"기둥으로 옮김");

        if(no>1)
            move(no-1,6-x-y,y);
    }

    public static void main(String[] args){
        Scanner stdIn=new Scanner(System.in);

        System.out.println("하노이의 탑");
        System.out.printf("원반 개수:");
        int n= stdIn.nextInt();

        move(n,1,3);
    }
1. 바닥 원반을 제외한 그룹(원반[1]~원반[no-1])을 시작 기둥에서 중간 기둥으로 옮긴다.
2. 바닥 원반 no를 시작 기둥에서 목표 기둥으로 옮겼음을 출력
3. 바닥 원반을 제외한 그룹(원반[1]~원반[no-1)을 중간 기둥에서 목표 기둥으로 옮긴다.

## 8퀸 문제
### 8퀸 문제란?
8퀸 문제(8-Queen problem)은 재귀 알고리즘에 대한 이해를 돕기 위한 예제로 자주 등장할 뿐만 아니라 19세기의 유명한 수학자 카를 프리드리히 가우스가 잘못된 해답을 낸 사실로도 잘 알려진 문제이다.
> ### 문제
> 서로 공격하여 잡을 수 없도록 8개의 퀸을 8X8체스판에 놓으시오(퀸은 서 있는 지점에서 체스판의 어떤지점으로는 여덟 방향으로 직선 이동이 가능

#### 퀸 배치하기
8개의 퀸을 배치하는 조합은 체스판 64칸에서 퀸 1개를 배치할 떄는 아무곳이나 선택가능하다. 다음 퀸을 배치할 때는 나머지 63칸에서 임의로 선택한다. 마찬가지로 8번째 까지 생각하면 다음과 같다.
> 64X63X62X61X60X59X58X57=179,462,987,637,760
가지의 조합이 만들어진다. 그런데 이 조합이 8퀸 문제의 조건을 만족하는지 조사하는 것은 현실적이지 않음. 퀸은 자신과 같은 열에 있는 다른 퀸을 공격할 수 있으므로 아래와 같은 규칙을 세운다.
> [규칙1] 각 열에 퀸 1개만 배치한다.
이렇게 하면 퀸을 배치하는 조합의 수는 많이 줄어들지만 
> 8 X 8 X 8 X 8 X 8 X 8 X 8 X 8= 16,777,216
가지로 엄청나게 많다. 하지만 이 가운에 8퀸 문제를 만족하는 풀이가 없다 왜냐하면 퀸은 자신과 같은 행에 있는 다른 퀸을 공격할 수 있기 때문이다. 
그래서 다음 규칙을 추가함
> [규칙2] 각 행에 퀸을 1개만 배치한다.

### 가지 뻗기

배열 pos는 퀸의 배치를 나타낸다. i열에 놓인 퀸의 위치가 j열이라면pos[i]의 값을 j로 한다. 예를 들어 pos[0]=0이면 0열의 퀸이 0행에 배치된 상태라고 생각하자
이때 set메서드는 pos[i]에 0부터 7까지의 값을 순서대로 만드는 재귀 메서드 이다. 매개변수 i가 이 퀸을 배치 할 열이다.
    
    // 각 열의 퀸의 위치를 출력
    static void print(){
        for(int i=0;i<8;i++)
            System.out.printf("%2d ",pos[i]);
        System.out.println();
    }
    
    // i열에 퀸을 놓는다
    static void set(int i){
        for (int j=0;j<8;j++){
            pos[i]=j;               //퀸을 j행에 배치
            if(i==7)                //모든 열에 배치함
                print();
            else
                set(i+1);           //다음 열에 퀸을 배치
            
        }
    }
    public static void main(String[] args){
        set(0);                 //0열에 퀸을 배치한다
    }

이렇게 가지를 뻗으며 퀸을 배치하는 조합을 모두 나열을 했다. 이러한 방법을 가지 뻗기(branching)라고 한다. 하노이의 탑이나 8퀸 문제처럼 문제를 세분화하고 세분된 작은 문제의 풀이를 결합해 전체 문제를 풀이하는 기법을 분할 정복법(divide and conquer)이라고 한다.
물론 문제를 세분할 때는 작은 문제의 풀이에서 원래 문제의 풀이가 쉽게 도출될 수 있게 설계해야한다.
