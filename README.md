# algorithm
## 클래스 본체와 멤버
1. 클래스 본체에서는 다음과 같은 내용을 선언할 수 있다.
   - 멤버(필드/메서드/중첩(nested)클래스/중첩(nested)인터페이스)
   - 클래스 초기화/인스턴스 초기화
   - 생성자
2. 필드/메서드/생성자를 선언할 때 publi/protected/private을 지정할 수 있다.
3. 메서드/생성자는 다중으로 정의(오버로드)할 수 있다.
4. final로 선언한 필드는 한 번만 값을 대입할 수 있다.
5. 생성자는 새로 생성한 인스턴스의 초기화를 위해 사용
> 오버로드란 메서드나 생성자를 정의할 때 형식은 다르지만 같은 이름을 붙이는것
#### 클래스의 예
class A{

      private int f1; //비공개 필드  
      protected int f2;//한정 공개 필드
      public int f3;   // 공개 필드
      
      static final int S1=0;  //정적 상수 필드
      
      public A(){             //생성자
          f1=f2=f3=0;
     }
     public A(int f1,int f2,int f3){  //생성자
        this.f1=f1;
        this.f2=f2;
        this.f3=f3;
     }
     public void setF1(int f){      //메서드 F1의 setter
        f1=f;
     }
     
     public int getF1(){            //메서드 F1의 getter
        return f1;
     }   
}

#### 공개 클래스
클래스 접근 제한자 public을 붙여 선언한 클래스, 다른 패키지에서 사용할 수 있는 공개 클래스(public class)이다.
#### final 클래스
클래스 접근 제한자 final을 붙여 선언한 클래스로, 서브 클래스를 가질 수 없다.(새로운 클래스를 상속할 수 없다).파이널 클래스(final class)가 된다.
#### 파생 클래스 
클래스 A를 직접 상위 클래스(direct superclass)로 하려면 선언할 때 extends A를 추가해야 한다. 이때 선언한 클래스는 클래스 A의 직접 서브 클래스(direct subclass)가 된다.
클래스 선언에 extends가 없는 클래스의 상위 클래스는 Object 클래스가 된다.

#### 인터페이스 구현
인터페이스 X를 구현하려면 선언에 implements X를 추가해야한다. 
 class Y implements X{
 //...
 }
 #### 추상 클래스
 클래스 접근 제한자 abstract를 붙여 클래스를 선언하면 추상 메서드를 가질 수 있는 추상 클래스(abstract class)가 된다. 추상 클래스형은 불완전한 클래스이므로 인스턴스를 만들 수 없다.
 - 추상 메서드란 실체가 정의되지 않은 메서드이다. 실체는 서브 클래스에서 정의
 #### 중첩 클래스
 클래스 또는 인터페이스 안에 선언한 클래스는 중첩 클래스(nested class)가 된다.
   - 멤버 클래스(member class)는 그 선언이 다른 클래스 또는 인터페이스 선언에 둘러싸인 클래스이다.
   - 내부 클래스(inner class)는 명시적으로도 암묵적으로도 정적(static)으로 선언되지 않은 중첩 클래스이다. 정적 초기화나 멤버 인터페이스 선언을 할 수 없다. 그리고 컴파일을 할 때 상수 필드가 아닌 한 정적 멤버를 선언할 수 없다.
   - 지역 클래스(local class)는 이름이 주어진 중첩 클래스인 내부 클래스이다. 어떤 클래스 멤버도 될수 없다.

## 배열검색
### 알고리즘
1. 선형 검색: 무작위로 늘어놓은 데이터 모임에서 검색을 수행
2. 이진 검색: 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행
3. 해시법: 추가,삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
      - 체인법: 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
      - 오픈 주소법: 데이터를 위한 해시 값이 충동할 때 재 해시하는 방법

#### 어떤 목적을 이루기 위해 선택할 수 있는 알고리즘이 여러 가지인 경우에는 용도나 목적, 실행 속도, 자료구조 등을 고려하여 알고리즘을 선택해야한다.

## 선형 검색
배열에서 검색하는 방법 중 가장 기본적인 알고리즘
요소가 직선모양으로 늘어선 배열에서 검색은 원하는 키 값을 갖는 요소를 만날때까지 맨앞부터 순서대로 요소를 검색하는것을 선형 검색(linear search)또는 순차 검색(sequential search)라는 알고리즘이라고 한다.

> ## 무한 루프 구현
> while문은 무한루프 구조를 이루고 있다. 이 구조는 무한하게 반복하는 구조로 되어 있지만 break문이나 return 문을 사용하면 루프에서 빠져나올 수 있다.
> do문에 의한 무한 루프 구현은 권장하지 않음( 끝까지 읽지 않으면 무한 루프인지 알수 없다)


### 보초법
선형 검색은 반복할때마다 종료조건을 모두 판단한다.
> 종료조건
> 1. 검색할 값을 반견하지 못하고 배열의 끝을 지나간경우
> 2. 검색할 값과 같은 요소를 발견한 경우
이 비용을 반으로 줄이는 방법이 보초법(sentinel method)이다.
검색하기 전 검색하고 자하는 키값을 맨 끝 요소에 저장한다. 이때 저장하는 값을 보초(sentinel)이라고 한다.
이렇게 하면 원하는 키 값을 찾지 못했을 때 판단하는 종료조건이 없어도 된다.
보초는 반복문에서 종료 판단 횟수를 2회에서 1회로 줄이는 역할을 한다.

## 이진검색
이진 검색 알고리즘을 적용하는 전제 조건은 데이터가 키값으로 이미 정렬(sort)되어 있다는 것이다.
이진 검색은 선형검색보다 좀 더 빠르게 검색할 수 있다는 장점이 있다.
이진 검색은 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘이다.

### 복잡도
프로그램의 실행 속도는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라진다.
알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도(complexity)라고 한다.
복잡도는 아래의 두가지 요소를 가지고 있다.
> 1. 시간복잡도(time complexity):실행에 필요한 시간을 평가한 것
> 2. 공간복잡도(space complexity):기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
#### 선형 검색의 시간 복잡도
    static int seqSearch(int[] a,int n,int key){
        int i=0;  //한번만 실행함 복잡도 O(1)
        while(i<n){        //복잡도 O(n)
            if(a[i]==key) //복잡도 O(n)
                return i;//검색 성공 1을 반환 한번만실행함 복잡도O(1)
            i++;        //O(n)
        }
        return -1;//검색실패 -1을 반환 한번만실행함 복잡도O(1)
    }
    
    
 > ## 컴퓨터에는 n/2나 n의 차이는 크지 않다
 > n/2번 실행했을 때 복잡도를 O(n/2)가아닌O(n)으로 표현하는 이유는 n의 값이 무한히 커진다고 가정햇을때 그 값의 차이가 무의미해 지기때문이다.
 > 마찬가지로 100번 실행하는 경우에도 O(100)이아닌 O(1)로 표현, 컴퓨터가 100번계산하닌 시간과 1번계산하는 시간의 차이는 사람이 느낄 수없을정도로 굉장히 작기때문이다.
 

그런데 n이 점점 커지면 O(n)에 필요한 계산 시간은 n에 비레하여 점점길어진다. 이와 달리 O(1)에 필요한 계산 시간은 변하지 않는다. 일반적으로 O(f(n))과 O(g(n))의 복잡도를 계산하는 방법은 아래와 같다.
O(f(n))+O(g(n))=O(max(f(n),g(n)))
2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은쪽의 복잡도를 우선시 한다. 둘이 아니라 셋 이상의 계산으로 구성된 알고리즘도 마찬가지이다. 다시 말해 전체 복잡도는 차원이 가장 높은 복잡도를 선택한다 그러므로 선형 검색 알고리즘의 복잡도를 구하면 아래처럼 O(n)이 된다.
O(1)+O(n)+O(n)+O(1)+O(n)+O(1)=O(max(1,n,n,1,n,1))=O(n)

### 이진 검색의 시간복잡도
이진검색법을 이용하면 검색할 요소의 범위를 절반씩 좁힐 수 있다.
    static int binSearch(int[] a,int n,int key){
        int pl=0;           //검색범위의 첫 인덱스  실행횟수 1/복잡도 O(1)
        int pr=n-1;         //검색범위의 끝 인덱스  실행횟수 1/복잡도 O(1)

        do{
            int pc=(pl+pr)/2;   //중앙요소의 인덱스 실행횟수 log n/복잡도 O(log n)
            if(a[pc]==key)      // 실행횟수 log n/복잡도 O(log n)
                return pc;      //검색 성공 실행횟수 1/복잡도 O(1)
            else if(a[pc]<key)  //실행 횟수 log n/복잡도 O(log n)
                pl=pc+1;        //검색 범위를 뒤쪽 절반으로 좁힘 실행 횟수 log n/복잡도 O(log n)
            else
                pr=pc-1;        //검색 범위를 앞쪽 절반으로 좁힘 실행 횟수 log n/복잡도 O(log n)
        }while(pl<=pr);         //실행 횟수 log n/복잡도 O(log n)
        return -1;              //검색 실패 실행 횟수 1 /복잡도 O(1)
    }

이진 검색 알고리즘의 복잡도를 구하면 아래처럼 O(logn)을 얻을 수 있다.
O(1)+O(1)+O(logn)+O(logn)+O(1)+O(logn)+...+O(1)=O(logn)

### 클래스 메서드와 인스턴스 메서드
Java메서드의 종류
1. 인스턴스 메서드(비정적 메서드):static을 붙이지 않고 선언한 메서드
2. 클래스 메서드(정적 메서드): static을 붙여 선언한 메서드
둘의 차이점은 메서드가 인스턴스에 포함되는지 여부이다.
클래스 메서드는 클래스 전체에 대한 처리를 담당 인스턴스 메서드와 처리 영역을 구분하기 위해 주로 사용
클래스 메서드와 마찬가지로 클래스 변수도 인스턴스에 포함되지 않는 변수이다. 또한 인스턴스의 개수와 관계없이 1개만 만들어 진다.
인스턴스 메서드와 클래스 메서드는 호출하는 방식도 다르다.
> 인스턴스 메서드 호출 시: 클래스형 변수 이름.메서드 이름
> 클래스 메서드 호출시 : 클래스 이름.메서드 이름

### 객체의 배열에서 검색하기
객체의 배열에서도 검색할 수 있다. 

> ### 자연정렬(natural ordering)
> binarySearch메서드에 배열과 키 값을 전달하는 간단한 방법으로 검색할 수 있는 이유는 String 클래스가 Comparable<T> 인터페이스와 comparetTo메서드를 구현하고 있기 때문이다.
